# 비동기 프로그래밍
## 동기식 처리모델과 비동기식 처리모델
함수를 호출하면 함수코드가 평가되어 함수의 실행 컨텍스트가 생성된다. 이때 생성된 함수의 실행 컨텍스트는 실행 컨택스트 스택(콜스택)에 푸시되고 함수코드가 실행된다. 함수 코드의 실행이 종료되면 함수의 실행 컨텍스트는 실행 컨텍스트 스택에서 팝되어 제거된다.

함수가 실행되려면 반드시 실행 컨텍스트 스택에 푸시되어야 한다. 다시 말해 실행 컨텍스트 스택에 푸시되는 것은 바로 함수의 실행의 의미한다. 따라서 함수가 호출된 순서대로 순차적으로 실행되는 이유는 함수가 호출된 순서대로 실행 컨텍스트 스택에 푸시하기 때문이다. 이처럼 **함수의 실행 순서는 실행 컨텍스트 스택으로 관리된다.**

**자바스크립트의 엔진은 단 하나의 실행 컨텍스트 스택을 갖는다.** 이는  함수를 실행할 수 있는 창구가 단 하나이며 동시에 2개 이상의 함수를 동시에 실행할 수 없다는것을 의미한다. 실행 컨텍스트의 최상위 스택(실행중인 실행 컨텍스트)을 제외한 모든 실행 컨텍스트는 모두 실행 대기 중인 태스크들이다. 대기 중인 태스크들은 현재 실행 중인 실행 컨텍스트가 팝되어 실행 컨텍스트 스택에서 제거되면, 즉 현재 실행 중인 함수가 종료하면 비로소 실행되기 시작한다.

이처럼 자바스크립트 엔진이 동작하는 브라우저 환경이나 Node.js환경은 한번에 하나의 태스크(task)만을 실행 할 수 있는 **싱글 스레드(single thread)** 방식으로 동작한다.

싱글 스레드 방식은 한번에 하나의 태스크만을 실행할 수 있기때문에 처리에 시간이 걸리는 태스크를 실행하는 경우, **블로킹(blocking, 작업중단)**이 발생한다. 예를 들어 setTimeout 함수와 유사하게 일정시간이 경과한 후에 콜백함수를 호출하는 sleep 함수를 구현해보자.

```
function sleep(func, delay) {
  const delayUntil = Date.now() + delay;
  while(Date.now() < delayUntil);
  func();
}

function foo() {
  console.log('foo');
}

function bar() {
  console.log('bar');
}

/**
 * 동기식 함수이기 때문에 함수몸체 내부의 코드가 실행되고나서
 * bar() 함수가 호출됨
 * 3초가 대기후 foo 함수가 실행 그후 bar 함수 실행
 */
sleep(foo, 3 * 1000);
bar();
```
위예제는 일정시간이 경과한 후 foo함수를 호출한후 bar함수를 호출한다. 이때 foo함수는 3초이후에 호출되기 때문에 3초후 foo 함수가 실행되고 나서야 bar함수가 호출된다. 이처럼 **현재 실행중인 태스크가 종료될때까지 다음 태스크가 대기하는 방식을 동기식 처리 모델(synchronuos processing model)이라고 한다.** 동기식 처리 모델은 태스크를 순차적으로 하나씩 처리하는 방식이다.

동기식 처리 모델은 태스크를 순차적으로 처리하므로 실행순서가 직관적이라는 장점이 있다. 하지만 앞선 태스크가 종료할 때까지 이후 태스크들이 블로킹되는 단점이 있다. 위 예제의 sleep 함수는 3초가 대기하다가 인수로 전달받은 콜백함수 foo를 호출한다. 따라서 sleep 함수가 종료된 이후 실행될 태스크인 bar함수는 3초이상 블로킹된다.

위 예제를 setTimeout 함수를 사용하여 수정해보도록 하자
```
function foo() {
  console.log('foo');
}

function bar() {
  console.log('bar');
}

setTimeout('foo', 3000);
bar();
```
타이머 함수 setTimeout은 앞서 살펴본 sleep함수와 유사하게 일정 시간이 경과한 이후에 콜백 함수를 호출하지만 setTimeout 이후의 태스크들을 블로킹하지 않고 곧바로 실행한다. 이처럼 현재 실행중인 태스크가 종료되지 않은 상태라고 하더라도 다음 태스크를 곧바로 실행하는 방식을 **비동기식 처리모델(Asynchronous processing model)이라고 한다.**

자바스크립트의 타이머함수(setTimeout, setInterval), HTTP 요청은 비동기식 처리모델로 동작한다. 비동기식 처리모델은 자바스크립트에 동시성을 부여하여 싱글스레드의 단점을 보완해준다.
## 이벤트 루프와 동시성
자바스크립트의 특징 중 하나는 싱글스레드로 동작한다는 것이다. 앞서 살펴본 바와 같이 싱글스레드 방식은 한번에 하나의 태스크만을 처리할 수 있다는것을 의미한다. 하지만 브라우저가 동작하는 것을 살펴보면 많은 태스크가 동시에 처리되는 것처럼 느껴진다.

예를 들어, 애니메이션 효과를 통해 어떤 HTML요소가 움직이면서 클릭이벤트를 처리하기도 하고, HTTP 요청을 통해 데이터를 가지고 오면서 렌더링 하기도 한다. 이처럼 **자바스크립트의 동시성(Concurrency)을 지원하는 것이 바로 이벤트 루프**이다.

구글의 V8을 비롯한 대부분의 자바스크립트 엔진은 크게 2개의 영역으로 구분할 수 있다.
- 콜스택(Call Stack, 실행 컨텍스트 스택)
<br><br>코드의 평가에의해 생성된 실행 컨텍스트가 추가(push)되고 제거(pop)되는 스택 자료구조

- 힙(Heap)
<br><br>객체가 할당되는 구조화되지 않은 넓은 메모리 영역이다.

이와같이 자바스크립트 엔진은 단순히 작업이 요청되면 콜스택을 통해 요청된 작업을 순차적으로 실행할 뿐이다. 때문에 동시성을 위해 지원되는 비동기 요청 처리는 자바스크립트 엔진이 하는것이 아니라 자바스크립트 엔진을 구동하는 환경, 즉 브라우저 혹은 Node.js가 담당한다. 이를 위해 브라우저 환경은 태스크 큐와 이벤트루프를 제공한다.

- 태스크 큐(Task queque/Event queque/callback queque)
<br><br>타이머 함수와 같은 비동기 처리함수의 콜백함수 또는 이벤트 핸들러가 일시적으로 보관되는 영역이다. 태스크 큐에서 보관중인 함수는 콜 스택이 비어졌을 때 이벤트 루프에의해 순차적(FIFO, First In First Out)으로 콜 스택으로 이동된어 실행 된다. 즉, 태스크 큐에 임시 보관된 함수들은 비동기 처리모델로 동작한다.

- 이벤트 루프(Event Loop)
<br><br>콜 스택에 현재 실행중인 실행 컨텍스트가 있는지 그리고 태스크 큐에 대기중인 함수(콜백함수, 이벤트 핸들러등)가 있는지 반복하여 확인한다. 만약 콜스택이 비어있으면 태스크 큐에서 대기중인 함수를 순차적(FIFO)으로 콜스택으로 이동시킨다.

브라우저 환경에서 아래 예제가 어떻게 작동할지 살펴보도록 하자.
```
function foo() {
  console.log('foo');
}

function bar() {
  console.log('bar');
}

setTimeout(foo); // 인수 전달을 생략한 경우, 기본값 0이 지정된다.
bar();
// bar -> foo
```
1. 전역코드가 평가되어 전역실행 컨텍스트가 생성되고 콜 스택에 푸시된다.

1. 전역 코드가 실행되기 시작하여 setTimeout 함수가 호출된다. 이때 setTimeout 함수의 실행 컨텍스트가 생성되고 콜 스택에 푸시되어 현재 실행중인 실행 컨텍스트가 된다.

1. 타이머 함수 setTimeout에 의해 타이머가 설정된다. **setTimeout은 브라우저의 Web API이므로 타이머 설정처리는 자바스크립트 엔진이 아닌 브라우저가 수행한다.** 이후 브라우저에 설정된 타이머가 만료되면 콜백함수 foo가 이벤트 루프에 푸시된다. 위 예제의 경우 지연시간(delay)이 생략되었으므로 기본값 0이 지정된다. 단 지연시간이 4ms 이하인 경우 최소 지연시간 4ms가 설정된다. 따라서 **4ms 후에 콜백함수 foo가 이벤트 루프에 푸시되어 대기하게 된다.** 이 처리 또한 자바스크립트 엔진이아닌 브라우저가 수행한다. 이것으로 브라우저 처리는 끝나게되고 다시 자바스크립트 엔진이 실행되어 setTimeout 함수가 종료되어 콜스택에서 팝된다. 이처럼 setTimeout으로 호출을 예약한 콜백 함수는 정확히 지연 시간 후에 호출된다는 보장은 없다. 지연 시간 이후에 콜백 함수가 이벤트 루프에 푸시되어 대기하게 되지만 콜 스택이 비어야 호출되므로 약간의 시간차가 발생할 수 있기 때문이다.

1. bar 함수가 호출된다. 이때 bar 함수의 함수 실행 컨텍스트가 생성되고 콜스택에 푸시되어 현재 실행중인 실행 컨텍스트가 된다. 이후 bar함수가 종료되어 콜스택에서 팝된다.

1. 전역 코드 실행이 종료되고 전역실행 컨텍스트가 팝된다. 이로써 콜 스택은 아무런 실행 컨텍스트도 존재하지 않게 된다.

1. 이벤트 루프에의해 콜 스택이 비어있음을 감지하고 3에서 setTimeout 함수에 의해 이벤트 루프에 푸시되어 대기 중인 콜백함수 foo가 콜스택에 푸시된다. 이처럼 **비동기 함수인 setTimeout의 콜백함수인 foo함수는 태스크 큐에 푸시되어 대기하다가 콜스택이 비게되면, 다시말해 전역코드 및 명시적으로 호출된 함수가 모두 종료하게되면 비로소 콜스택에 푸시되어 실행된다.**

1. 콜백 함수 foo의 함수 실행 컨텍스트가 생성되고 콜스택에 푸시되어 현재 실행중인 실행 컨텍스트가 된다. 이후 foo 함수가 종료되어 콜스택에서 팝된다.

자바스크립트는 싱글스레드 방식으로 동작하게 된다. 이때 **싱글 스레드 방식으로 동작하는 것은 브라우저가 아니라 자바스크립트 엔진이라는 것에 주의해야한다.**

예를 들어, 타이머 함수 setTimeout의 모든 처리가 자바스크립트 엔진에서 수행된다고 가정해 보자. 이때 setTimeout의 지연 처리를 위한 타이머 설정도 자바스크립트 엔진에서 수행될 것이므로 대기 시간 동안 어떤 태스크도 실행할 수 없다. 즉, setTimeout의 타이머 설정은 자바스크립트 엔진에서 싱글 스레드 방식으로 동작해서는 비동기적으로 동작할 수 없다.

브라우저는 자바스크립트 엔진 이외에도 렌더링 엔진과 Web API를 제공한다. Web API는 ECMAScript 사양에 정의된 함수가 아니라 브라우저에서 제공하는 API이며 DOM API와 타이머 함수, HTTP 요청(Ajax)와 같은 비동기식 처리를 포함한다. 위 예제와 같이 브라우저의 Web API인 타이머 함수 setTimeout이 호출되면 콜 스택에 푸시되어 실행된다. 이때 setTimeout의 2가지 기능인 일정 시간 대기하기 위한 타이머 설정과 타이머가 만료하면 콜백 함수를 태스크 큐에 등록하는 처리는 자바스크립트 엔진이 아니라 브라우저가 실행한다. 즉, 브라우저와 자바스크립트 엔진이 협력하여 setTimeout을 수행한다.

동기식 처리 모델은 블로킹이 발생하는 단점이 있지만 비동기식 처리 모델은 블로킹이 발생하지 않는다. 하지만 비동기식 처리 모델로 동작하는 코드는 순차적으로 실행되지 않아 가독성이 좋지 않고 콜백 헬을 유발시키하며 에러 처리가 곤란하다는 단점이 있다