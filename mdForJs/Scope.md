# 스코프
> 모든 식별자(변수 이름, 함수 이름, 클래스 이름 등)는 자신이 선언된 위치에 의해 다른 코드가 식별자 자신을 참조할 수 있는 유효 범위가 결정된다. 이를 스코프(Scope, 유효범위)라 한다. 즉, 스코프는 식별자가 유효한 범위를 말한다.

        var x = 'global';
        console.log(x); // 결과 : global
        function foo(){
            var x = 'local';
            console.log(x);
        }
        foo(); // 결과 : local
## 1. 스코프의 종류
### 1.1 전역스코프
> 전역이란 코드의 제일 바깥부분을 말한다. 전역스코프를 가지는 변수는 어디에서든 값을 참조할 수 있다.
### 1.2. 지역스코프
> 지역은 함수의 몸체 내부를 말한다. 즉 함수안에서 선언된 변수는 지역스코프를 갖는 지역변수가 된다.
### 1.3. 함수레벨 스코프
> var 키워드로 선언된 변수는 오로지 함수의 코드 블록 만을 지역 스코프로 인정한다. 이러한 특성을 함수 레벨 스코프(Function level scope)라 한다. 

        var i = 10;

        // for문에서 선언한 i는 전역 변수이다. 이미 선언된 전역 변수 i가 있으므로 중복 선언된다.
        for (var i = 0; i < 5; i++) {
        console.log(i); // 0 1 2 3 4
        }

        // 의도치 않게 변수의 값이 변경되었다.
        console.log(i); // 5
- 블록 레벨 스코프를 지원하는 프로그래밍 언어에서는 for 문에서 반복을 위해 선언된 변수 i가 for 문의 코드 블록 내에서만 유효한 지역 변수이다. 이 변수를 for 문 외부에서 사용할 일은 없기 때문이다. 하지만 var 키워드로 선언된 변수는 블록 레벨 스코프를 인정하지 않기 때문에 변수 i는 전역 변수가 된다. 따라서 전역 변수 i는 중복 선언되고 그 결과 의도치 않은 전역 변수의 값이 재할당된다.
### 1.4. 렉시컬 스코프
        var x = 1;
        function foo(){
            var x = 10;
            bar();
        }
        function bar(){
            console.log(x);
        }
        foo(); // 1
        bar(); // 1
- 위 예제에서 bar함수는 전역에서 정의된 객체이다. 그리고 자바스크립트엔진이 런타임에 들어가기전에 먼저 암묵적으로 bar와 똑같은 함수의 이름으로 객체를 생성하고 할당하게 된다.<br><br>
- 이렇게 생성된 bar함수는 자신이 정의되고 평가되어 할당된 시점의 스코프를 가지게되고 이를 계속 기억하게 된다.<br><br>
- 그리고 bar 함수를 호출하게되면 자기자신이 호출된 위치가 아니라 자신이 생성될때 기억해두었던 스코프(여기선 전역스코프)에 따라 상위스코프를 검색하게된다.<br><br>
- **결론 : 함수의 스코프는 함수를 어디서 호출했는지가 아니라 함수를 어디서 정의했는지에 따라 상위 스코프를 결정한다.** 
## 2. 스코프 체인
> 함수몸체 내부에서 함수를 정의 할수 있으므로 함수의 지역 스코프도 중첩 될 수 있다. 이것은 스코프는 함수의 중첩에 의해 계층적 구조를 갖는다는것을 의미한다.

        var x = 'global x';
        var y = 'global y';
        const outer = function(){
            var z = 'outer z';
            console.log(x);
            console.log(y);
            console.log(z);
            const inner = function(){
                var x = 'inner x'; 
                console.log(x);
                console.log(y);
                console.log(z);
            }
            inner(); 
        }
        outer(); // global x, global y, outer z, inner x, global y, outer z (실행컨텍스트에 따른 작업순서이므로 console.log가 찍히는 순서도 중요하다.)
        console.log(x); // global x
        console.log(z); // undefined
- 위에 코드는 자바스크립트 엔진이 스코프 체인을 통해 변수를 참조할때 변수를 참조하는 스코프에서 시작해서 상위 스코프방향으로 이동하면서 선언된변수를 검색하는 것을 보여주는 코드이다.
### 2.1. 스코프 체인에 의한 변수검색
> 아래의 설명은 스코프 체인에서 예시로 보여준코드를 예로 설명
1. 변수 x를 참조하는 코드의 스코프인 inner 함수의 지역 스코프에서 변수 x가 선언되었는지 검색한다. 함수 inner 내에는 선언된 변수 x가 존재한다. 따라서 검색된 변수를 참조하고 검색을 종료한다.<br><br>
1. 변수 y를 참조하는 코드의 스코프인 inner 함수의 지역 스코프에서 변수 y가 선언되었는지 검색한다. 함수 inner 내에는 변수 y의 선언이 존재하지 않으므로 상위 스코프인 함수 outer의 지역 스코프로 이동한다. 함수 outer 내에도 변수 y의 선언이 존재하지 않으므로 또 다시 상위 스코프인 전역 스코프로 이동한다. 전역 스코프에는 변수 y의 선언이 존재한다. 따라서 검색된 변수를 참조하고 검색을 종료한다.<br><br>
1.  변수 z를 참조하는 코드의 스코프인 inner 함수의 지역 스코프에서 변수 z가 선언되었는지 검색한다. 함수 inner 내에는 변수 z의 선언이 존재하지 않으므로 상위 스코프인 함수 outer의 지역 스코프로 이동한다. 함수 outer 내에는 변수 z의 선언이 존재한다. 따라서 검색된 변수를 참조하고 검색을 종료한다.<br><br>
1. **결론 : 상위 스코프에서 유효한 변수는 하위 스코프에서 자유롭게 참조할 수 있지만 하위 스코프에서 유효한 변수를 상위 스코프에서 참조할 수 없다는 것을 의미한다.**<br><br>
### 2.2. 스코프 체인에 의한 함수검색
        var foo = function(){
            console.log('global function foo');
        }
        var bar = function(){
            var foo = function(){
                console.log('local function foo');
            }
            foo();
        }
        bar(); //  'local function foo' 
        foo(); // 'global function foo'
- 변수 검색과 똑같이 foo함수가 실행될때 상위함수(bar)의 스코프내에서 foo자신의 값을 먼저 찾기때문에 bar함수안의 foo함수가 실행된다.