# 전역변수의 문제점
## 1. 변수의 생명주기
### 1.1. 지역변수의 생명주기
    const local = function(){
      const dotax = 'local function foo';
      console.log(dotax);
      return dotax;
    }
    local();
    console.log(dotax); // dotax is not defined
- 함수내부에서 선언한 변수는 함수가 호출된 직후에 함수에 다른 코드가 실행되기 이전에 자바스크립트 엔진에 의해서 먼저실행되어 undefined로 초기화된다.

- 그후 함수내부의 문들이 순차적으로 실행되기 시작하고 변수할당문이 실행되면서 변수 x에 값이 할당된다.

- **결론 : 지역변수의 생명주기는 함수의 생명주기와 일치한다.**
### 1.2. 함수내부에서 지역변수 호이스팅
    const xyyy = 'global';
    function foo() {
        console.log(xyyy); // 1
        var xyyy = 'local';
        return xyyy;
    }
    foo(); // 'undefined'
    console.log(xyyy); // 'global'
- foo함수를 실행하면서 변수 x에 대한 호이스팅때문에 undefined로 초기화 되어있는 상태이다. (1번)<br><br>
- 때문에 변수 x에 대한 할당이 되기전에 변수를 참조하게되면 undefined를 반환한다.<br><br>
- **결론 : 호이스팅은 스코프 단위로 동작하게된다. 때문에 함수내부의 변수는 함수가 실행될때 호이스팅이 된다는것을 알아야한다.**
### 1.2. 전역변수의 생명주기
> 함수와 달리 전역코드는 명시적호출 없이 실행된다. 때문에 전역코드는 함수호출과 같이 전역코드를 실행하는 특별한 진입점이 없고 코드가 로드되자마자 곧바로 해석되고 실행된다.
- var로 선언한 변수는 전역객체 ( 클라이언트 사이드환경 : window, node.js환경 : global )의 프로퍼티가 된다.<br>**이는  전역변수의 생명주기가 전역객체의 생명주기와 일치한다는것을 말한다.**
## 2. 전역변수의 문제점
1. 암묵적 결합<br>
변수의 유효범위가 크면클수록( 암묵적 결합을 허용하는 말과 같다. ) 코드의 가독성은 나빠지고 의도치않게 상태가 변경될수있는 위험이 있다.

1. 긴 생명 주기<br>
전역변수는 생명주기가 길다. 따라서 메모리 리소스도 오랜기간 소비하고 모든함수가 참조할수 있기때문에 상태가 의도치않게 변경될 경우도 생기게된다.

1. 스코프 체인상에서 종점에 존재<br>
전역변수는 스코프 체인상 종점에 존재하기 때문에 변수를 검색할때 전역변수는 가장마지막에 검색된다. => 변수의 검색속도가 가장느리다.

1. 네임스페이스 오염<br>
파일이 분리되어 있더라도 하나의 전역스코프를 공유한다. 따라서 다른 파일내에 동일한 변수명으로 존재할경우 예상치못한 결과를 가져올수 있다.
## 3. 전역변수 사용 억제방법
> 전역변수를  반드시 사용하여야 할 이유를 찾지 못한다면 지역변수를 사용해야한다. 변수의 스코프는 좁을수록 좋다.
### 3.1. 즉시실행 함수
- 모든 코드를 즉시 실행함수로 감싸면 모든 변수는 즉시 실행함수의 지역 변수가 된다. 이러한 방법을 사용하여 전역변수의 사용을 
억제하는것이다.

        (function () {
          var foo = 10; // 즉시 실행 함수의 지역 변수
          // ...
        }());

        console.log(foo); // ReferenceError: foo is not defined
### 3.2. 네임스페이스 객체
- 전역에 네임스페이스 역할을 담당할 객체를 생성하고 전역변수처럼 사용하고 싶은 변수를 프로퍼티로 추가하는 방법이다.<br><br>

      var MYAPP = {}; // 전역 네임 스페이스 객체

      MYAPP.person = {
        name: 'Lee',
        address: 'Seoul'
      };

      console.log(MYAPP.person.name); // Lee

- 네임스페이스를 분리하여 식별자 충돌을 방지하는 효과는 있지만 네임스페이스 자체가 전역변수에 할당되므로 그다지 유용한방법은 아니다.
### 3.3. 모듈 패턴
> 모듈 패턴은 클래스를 모방하여 관련이있는 변수와 함수를 모아 즉시실행함수로 감싸 하나의 모듈로 만든다. 모듈 패턴은 자바스크립트의 기능인 클로저를 기반으로 동작한다.<br>
**모듈패턴의 특징은 전역변수의 억제뿐만아니라 캡슐화까지 구현가능하다는것을 말한다.**<br>
java의 private public protected와 비슷한개념(접근제한자)

    const Counter = ( function (){
      // 접근제한자 선언된 변수라고 생각...
      var initNum = 0;

      // 외부로 공개할 메소드 혹은 데이터를 프로퍼티로가진 객체를반환.
      return {
        increase(){
          return ++initNum;
        },
        decrease(){
          return --initNum;
        }
      };
    })();
    // private 변수는 외부에서 참조할 수 없다.
    console.log(Counter.initNum); // undefined
    console.log(Counter.increase()); // 1
    console.log(Counter.increase()); // 2
    console.log(Counter.increase()); // 3
    console.log(Counter.decrease()); // 2
- 즉시 실행함수로 리턴하는 값은 외부에서 접근가능한(public개념) 변수나 함수를 객체에 담아서 반환한다. 때문에 외부에서 접근하게 하고싶지않은 변수나 함수는(private개념) 반환하는 객체에 추가하지 않음으로서 private 멤버가 된다.
### 3.4. ES6 모듈
> 전역 변수의 남발을 억제하기 위해 ES6에서 도입된 모듈을 사용할 수도 있다. 모던 브라우저(Chrome 61, FF 60, SF 10.1, Edge 16 이상)에서 ES6 모듈을 사용할 수 있다.
<br>script 태그에 type=”module” 어트리뷰트를 추가하면 로드된 자바스크립트 파일은 모듈로서 동작한다. 모듈의 파일 확장자는 mjs를 권장한다.

    <script type="module" src="lib.mjs"></script>
    <script type="module" src="app.mjs"></script>
- 하지만 ES6 모듈은 IE를 포함한 구형 브라우저는 동작하지 않으며, 브라우저의 ES6 모듈 기능을 사용하더라도 트랜스파일링이나 번들링이 필요하기 때문에 아직까지는 브라우저가 지원하는 ES6 모듈 기능보다는 Webpack 등의 모듈 번들러를 사용하는 것이 일반적이다.