# let,const와 블록레벨 스코프
## 1. var 키워드 문제점
> 같은 스코프 내에서 변수를 중복 선언하면 나중에 작성된 변수 선언문은 자바스크립트 엔진에 의해 var 키워드가 없는 것처럼 동작한다. 이때 에러는 발생하지 않는다.

### 1.1. 변수 중복선언 가능
> 만약 동일한 변수 이름이 이미 선언되어 있는 것을 모르고 변수를 중복 선언하면서 값까지 할당했다면 의도치 않게 먼저 선언된 변수값이 변경되는 부작용이 발생한다. 따라서 **변수의 중복 선언은 문법적으로 허용되지만 사용하지 않는 것이 좋다.**
### 1.2. 함수레벨 스코프
> var 변수는 오로지 함수레벨 스코프만은 지역변수로 인정한다. 따라서 제어문을 사용할때 의도치 않게 값이 변경되는 경우가 생길 수 있다.

    var i = 10;
    for(var i = 0; i < 100; i++){
      // doSomthing
    }
    console.log(i);
### 1.3. 변수 호이스팅
> var 키워드로 변수를 선언하면 변수 호이스팅에 의해 변수 선언문이 스코프의 선두로 끌어 올려진 것처럼 동작한다. 즉, 변수 호이스팅에 의해 var 키워드로 선언한 변수는 변수 선언문 이전에 참조할 수 있다. 단, 할당문 이전에 변수를 참조하면 언제나 undefined를 반환한다.<br>
**변수 선언문 이전에 변수를 참조하는 것은 변수 호이스팅에 의해 에러를 발생시키지는 않지만 프로그램의 흐름 상 맞지 않을 뿐더러 가독성을 떨어뜨리고 오류를 발생시킬 여지를 남긴다.**
## 2. let 키워드 (ES6)
### 2.1. 변수 중복선언금지
> let 키워드로 동일한 이름을 갖는 변수를 중복 선언하면 문법 에러(SyntaxError)가 발생한다.
### 2.2. 블록레벨 스코프
> let 키워드는 모든 코드블록(함수, 제어문등...)을 지역스코프로 인정하는 지역레벨 스코프를 따른다.

    let i = 99;
    const foo = function(){
      let i = 100;
      for( let i = 0; i < 5; i++){
        console.log(i); // 0, 1, 2, 3, 4
      }
      console.log(i); // 100
    }
    foo();
    console.log(i); // 99
### 2.3. 변수 호이스팅(var와 차이점)
> let 변수의 자바스크립트 엔진상의 흐름. 일시적 사각지대의 존재로 호이스팅이 존재하지 않는것처럼 느껴짐.<br>
hoisting -> 일시적사각지대(temporal dead zone; tdz) -> 초기화단계(undefined 할당) -> 할당단계(실질적인 값이 할당)
- var 키워드는 일시적 사각지대가 존재하지않기 때문에 변수가 할당는 런타임시점 이전에 var 키워드로 선언된 변수를 참조하면 undefined를 반환한다.
- 하지만 let 키워드로 선언한 변수는 **선언단계와 초기화단계가 분리되어 실행된다.**

      // 런타임이전에 변수가 선언 되었다 하지만 초기화는 진행되지않아서 변수를 참조할수 없고 참조하게 된다면 reference error (일시적 사각지대)
      console.log(param); // reference error : param is not defined
      let param; // 변수 선언단계
      console.log(param); // param = undefined
      param = 100; // 변수에 값할당
      console.log(param); // 100
### 2.4. 전역객체와 let
## 3. const 키워드 (ES6)
### 3.1. 선언과 초기화
### 3.2. 재할당 금지
### 3.3. 상수
### 3.4. 객체